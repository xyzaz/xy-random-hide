<?php

// -------------------------------------------------------------------------- //
// XyRndHide
//
// version 0.1b (2020-04-27)
// 
// Created by xyzazINwpPOINTpl
// 
// -------------------------------------------------------------------------- //
// WARNING!
// Intended userage is to hide strings from an accidental revealing!
// 
// Do not use it to encrypt any sensitive data because it will not be trully
// cryptographically secure!
//
// Can be also used to generate pseudorandom numbers basing on 60 bit seed.
//
// -------------------------------------------------------------------------- //
// DEPENDS ON:
// Hooray! It's independent!
//
// -------------------------------------------------------------------------- //
// USERAGE:
//
// $oHideA = new CXyRndHide( 'passphrase' );
//
// $sHidden = $oHideA ->hide( 'Hello!' );
// echo $sHidden . '<br>';
//
// $sHidden = $oHideA ->hide( 'Hello!' );
// echo $sHidden . '<br>';
//
// $sString = $oHideA ->show( $sHidden );
// echo $sString . '<br>';
//
// $oHideB = new CXyRndHide( 'passphrase', false );
//
// $sHidden = $oHideB ->hide( 'Hello!' );
// echo $sHidden . '<br>';
//
// $sHidden = $oHideB ->hide( 'Hello!' );
// echo $sHidden . '<br>';
//
// $sString = $oHideB ->show( $sHidden );
// echo $sString . '<br>';
//
// $oHideA ->setPin( 'other pass', false );
//
// $sHidden = $oHideA ->hide( 'Bye' );
// echo $sHidden . '<br>';
//
// $sHidden = $oHideA ->hide( 'Bye' );
// echo $sHidden . '<br>';
//
// $sString = $oHideA ->show( $sHidden );
// echo $sString . '<br>';
//
// $uRandom = $oHideA ->rand();
// echo 'random number 0-32767: ' . $uRandom . '<br>';
//
// $uRandom = $oHideA ->rand( 1 );
// echo 'random number 0-1: ' . $uRandom . '<br>';
//
// $uRandom = $oHideA ->rand( 31 );
// echo 'random number 0-2147483647: ' . $uRandom . '<br>';
//
// ADVANCED USERAGE:
//
// new CXyRndHide( $sPin, $bRandomize, $hiSeed, $loSeed )
//
// Arguments
// - $sPin 				- passphrase string
// - $bRandomize		- if false the hidden string will not be randomized
//						  hidden string for the same pin will look the same
// - $hiSeed			- highest 30 bits of 60 bits seed value
// - $loSeed			- lowest 30 bits of 60 bits seed value
//
// Returns
// - CXyRndHide object
//
// Notice: 
// Seed value is calculated from $sPin, you can provide $hiSeed and $loSeed
// to make it better. These numbers are added to calculated seed value.
//
// setPin( $sPin, $bRandomize, $hiSeed, $loSeed )
//
// Arguments
// - same as CXyRndHide
//
// Returns
// - does not return any value
//
// hide( $sString )
//
// Arguments
// - $sString			- string to hide, unicode supported
//
// Returns
// - hidden string
//
// show( $sHidden )
//
// Arguments
// - $sHidden			- previously hidden string
//
// Returns
// - revealed string
//
// Notice
// - exactly the same parameters must be provided to CXyRndHide or setPin
//   while hidding and revealing string
//
// rand( $nBits )
//
// Arguments
// - $nBits				- number of random bits to return
//
// Returns
// - preudorandom unsigned integer
//
// Notice
// - $nBits must be in range 1 to 31, maximum random value is 2147483647,
//   if argument is not provided by default 15 bit value is returned
//
// srand( $hiSeed, $loSeed )
//
// Initialises random number generator. If seed values are provided
// rand() returns the same sequence of pseudorandom numbers
//
// Arguments
// - $hiSeed			- highest 30 bits of 60 bit seed value
// - $loSeed			- lowest 30 bits of 60 bit seed value
//
// Notice
// - if arguments are not provided the random values will be used 
//
// -------------------------------------------------------------------------- //
// LIMITATIONS:
// Hidden text is longer than original text
// -------------------------------------------------------------------------- //
// TODO:
// -------------------------------------------------------------------------- //

namespace XyZaz;

// ----------------------------------------------------------------------------

class CXyRndHide
{
	// -----------------------------------------------------
	// We internally use UTF-16 because we have to be able
	// to process strings generated by javascript which uses UTF-16
	// -----------------------------------------------------
	
	// -----------------------------------------------------
	// Private static properties
	// -----------------------------------------------------
	
	// Do not change, code depends on these values
	private static $ms_n15 = 15;
	private static $ms_n30 = 30;
	// 32767 | 111111111111111
	private static $ms_bit15 = 0x7FFF;
	// 1073741823 | 111111111111111111111111111111
	private static $ms_bit30 = 0x3FFFFFFF;
	// 32768 | 1000000000000000
	private static $ms_bitBound15 = 0x8000;
	// 1073741824 | 1000000000000000000000000000000
	private static $ms_bitBound30 = 0x40000000;
	
	// -----------------------------------------------------
	// Private properties
	// -----------------------------------------------------
	
	private $P;
	private $pH;
	private $pL;
	
	private $bR;
	private $rH;
	private $rL;
	
	private $aH;
	private $aL;
	
	private $cH;
	private $cL;
	
	// Length of "P" pin array
	private $m_nPin;

	// -----------------------------------------------------
	// Private static methods
	// -----------------------------------------------------
	
	// Equivalent of javascript charCodeAt
	//
	private static function charCodeAt ( $a_sStr, $a_iPos )
	{
		return ( \ord( $a_sStr[ 2 * $a_iPos ] ) << 8 )
			+
			\ord( $a_sStr[ 2 * $a_iPos + 1 ] )
		;
	}
	
	// -----------------------------------------------------
	// Private methods
	// -----------------------------------------------------
	
	private function supportedChars ( $a_sString, & $ar_nChars )
	{
		// We internally use utf-16
		$a_sString =
			\mb_convert_encoding( $a_sString, 'UTF-16' )
		;
		
		$i14 = -1;
		$aResult = array();
		
		// Notice: eqivalent of javascript string.length!
		$nStr = \strlen( $a_sString ) / 2;
		
		// Two empty slots for randomizer params
		$j = $this ->bR ? 2 : 0;

		for ( $i = 0; $nStr > $i; $i ++ )
		{
			$iChr = self::charCodeAt( $a_sString, $i );

			if ( ( 0 > $iChr ) || ( 65535 < $iChr ) )
			{
				// Unsupported character
				$iChr = 63;
			}
			else if ( 16383 < $iChr )
			{
				if ( 0 > $i14 )
				{
					$iFlag = $i + $j ++;

					$aResult[ $iFlag ] = 16384;

					$i14 = 13;
				}
				
				if ( self::$ms_bit15 < $iChr )
				{
					$aResult[ $iFlag ] += 1 << $i14;
				
					// Highest bit goes to the flag
					$iChr %= self::$ms_bitBound15;
				}
			}
			$i14 --;

			$aResult[ $i + $j ] = $iChr;
		}
		$ar_nChars = $nStr + $j;
		
		return $aResult;
	}
	
	// -----------------------------------------------------
	
	private function restoreString ( $a_aChars, $a_nChars )
	{
		$i14 = -1;	
		$sResult = '';
		
		// Two empty slots to skip randomizer params
		$i = $this ->bR ? 2 : 0;

		for ( ; $a_nChars > $i; $i ++ )
		{
			$iChr = $a_aChars[ $i ];

			if ( ( 16383 < $iChr ) && ( 0 > $i14 ) )
			{
				$fFlag = $iChr - 16384;
				
				// Get next char if possible
				if ( $a_nChars <= ++ $i )
				{
					break;
				}
				$iChr = $a_aChars[ $i ];
	
				$i14 = 13;
			}
			// Add the highest bit if needed
			if ( ( 0 <= $i14 ) && ( $fFlag & ( 1 << $i14 ) ) )
			{
				$iChr += self::$ms_bitBound15;
			}
			$i14 --;
			
			$sResult .= \chr( $iChr >> 8 );
			$sResult .= \chr( $iChr & 255 );
		}
		return \mb_convert_encoding(
		
			$sResult,
			\mb_internal_encoding(),
			'UTF-16'
		);
	}
	
	// -----------------------------------------------------
	
	private function randomize ( & $ar_aChars, $a_nChars )
	{
		if ( \function_exists( 'random_int' ) )
		{
			$hiRnd = \random_int( 0, self::$ms_bitBound15 );
			$loRnd = \random_int( 0, self::$ms_bitBound15 );
		}
		else
		{
			$hiRnd = \rand( 0, self::$ms_bitBound15 );
			$loRnd = \rand( 0, self::$ms_bitBound15 );
		}
		
		$ar_aChars[ 0 ] = $hiRnd;
		$ar_aChars[ 1 ] = $loRnd;
		
		$this ->srand( $hiRnd, $loRnd );
		
		for ( $i = 2; $a_nChars > $i; $i ++ )
		{
			$ar_aChars[ $i ] =
				( $ar_aChars[ $i ] + $this ->rand() )
				%
				self::$ms_bitBound15
			;
		}
	}
	
	// -----------------------------------------------------
	
	private function unRandomize ( & $ar_aChars, $a_nChars )
	{
		$hiRnd = $ar_aChars[ 0 ];
		$loRnd = $ar_aChars[ 1 ];
		
		$this ->srand( $hiRnd, $loRnd );
		
		for ( $i = 2; $a_nChars > $i; $i ++ )
		{
			$iChr = $ar_aChars[ $i ] - $this ->rand();
			
			if ( 0 > $iChr )
			{
				$iChr += self::$ms_bitBound15;
			}
			$ar_aChars[ $i ] = $iChr;
		}
	}
	
	// -----------------------------------------------------
	// Public constructor
	// -----------------------------------------------------
	
	public function __construct (
		$a_sPin = '', $a_bRandomize = true, $a_hiSeed = 0, $a_loSeed = 0
	)
	{
		$this ->setPin( $a_sPin, $a_bRandomize, $a_hiSeed, $a_loSeed );
		
		// Init default random generator
		$this ->srand();
	}

	// -----------------------------------------------------
	// Public static methods
	// -----------------------------------------------------
	
	// -----------------------------------------------------
	// Public methods
	// -----------------------------------------------------
	
	public function setPin (
		$a_sPin = '', $a_bRandomize = true, $a_hiSeed = 0, $a_loSeed = 0
	)
	{
		// We internally use utf-16
		$a_sPin	= \mb_convert_encoding( $a_sPin, 'UTF-16' );
		
		// Zero if there is no pin provided
		$nPin =  0;
		$hiPin = 0;
		$loPin = 0;
		
		// This will be used as pin if no string
		$aPin = array( 0 );
		
		// Store previous rand value
		$hiPrev = $this ->rH;
		$loPrev = $this ->rL;
		
		if ( $a_sPin )
		{
			// Notice: eqivalent of javascript string.length!
			$nPin = \strlen( $a_sPin ) / 2;
			
			// Important!
			$loPin = $nPin;
			$hiPin = $nPin;
		}
		
		// Keep length
		$this ->m_nPin = $nPin;
		
		$this ->bR = ( false === $a_bRandomize ) ? false : true;
		
		for ( $i = 0; $nPin > $i; $i ++ )
		{
			// Ensure it is not greater than 32767
			$iChr = self::charCodeAt( $a_sPin, $i ) % self::$ms_bitBound15;
			$aPin[ $i ] = $iChr;
			
			$hiPin = ( $hiPin + $loPin + $iChr ) & self::$ms_bit30;
			$loPin = ( $hiPin * $iChr ) & self::$ms_bit30;
		}
		$this ->P = $aPin;
		
		if ( $a_hiSeed )
		{
			$hiPin += \abs( (int) $a_hiSeed ) % self::$ms_bitBound30;
		}
		if ( $a_loSeed )
		{
			$loPin += \abs( (int) $a_loSeed ) % self::$ms_bitBound30;
		}
		
		// Srand will % these values in case of overflow
		$this ->srand( $hiPin, $loPin );
		$this ->rand();
		
		$this ->pH = $this ->rH;
		$this ->pL = $this ->rL;
		
		// Restore prev rand value
		$this ->rH = $hiPrev;
		$this ->rL = $loPrev;
	}
	
	// -----------------------------------------------------
	
	public function srand ( $a_hiSeed = NULL, $a_loSeed = NULL )
	{
		if ( ( NULL !== $a_hiSeed ) || ( NULL !== $a_loSeed ) )
		{
			// Custom seed value not more than 30 bits long each part
			$a_hiSeed = \abs( (int) $a_hiSeed ) % self::$ms_bitBound30;
		
			// Custom seed value not more than 30 bits long each part
			$a_loSeed = \abs( (int) $a_loSeed ) % self::$ms_bitBound30;
		}
		else
		{
			if ( \function_exists( 'random_int' ) )
			{
				$a_hiSeed = \random_int( 0, self::$ms_bitBound30 );
				$a_loSeed = \random_int( 0, self::$ms_bitBound30 );
			}
			else
			{
				$a_hiSeed = \rand( 0, self::$ms_bitBound30 );
				$a_loSeed = \rand( 0, self::$ms_bitBound30 );
			}
		}
		
		// a is prime, a - 1 is dividable by 2 and 4
		// 171320439310783573 split into two 30 bit values:
		// 1001100000101001110000100000 100111111000100001010001010101
		// ^ hi (159554592)             ^ lo (669127765)
		$this ->aH = 159554592;
		$this ->aL = 669127765;
		
		// initial seed value is prime
		// 405281757203134997 split into two 30 bit values:
		// 10110011111110110011001110001 100100000010011111101000010101
		// ^ hi (377448049)              ^ lo (604633621)
		
		// Seed value is created by adding custom value to initial value
		// Notice: we are performing bit safe addition
		$a_hiSeed += 377448049;
		$a_loSeed += 604633621;
		$a_hiSeed &= self::$ms_bit30;
		$a_hiSeed += $a_loSeed >> self::$ms_n30;

		$this ->rH = $a_hiSeed & self::$ms_bit30;
		$this ->rL = $a_loSeed & self::$ms_bit30;

		// c is prime
		// 121796652209 split into two 30 bit values:
		// 1110001 011011101001010110110010110001
		// ^ hi    ^ lo
		$this ->cH = 113;
		$this ->cL = 463826097;
		
		// The m param is 2^60
		// We return from fifth to n'th highest bits as the random value
	}
	
	// -----------------------------------------------------
	
	public function rand ( $a_nBits = NULL )
	{
		// Return 15 random bits by default
		if ( NULL === $a_nBits )
		{
			$a_nBits = self::$ms_n15;
		}
		// Get randomizer param a
		$hiTmp = $this ->aH;
		$loTmp = $this ->aL;

		// Split it into four 15 bit pieces
		$hihiA = $hiTmp >> self::$ms_n15;
		$hiloA = $hiTmp & self::$ms_bit15;
		$lohiA = $loTmp >> self::$ms_n15;
		$loloA = $loTmp & self::$ms_bit15;
		
		// Get last randomizer value
		$hiTmp = $this ->rH;
		$loTmp = $this ->rL;

		// Split it into 15 bit pieces
		$hihiB = $hiTmp >> self::$ms_n15;
		$hiloB = $hiTmp & self::$ms_bit15;
		$lohiB = $loTmp >> self::$ms_n15;
		$loloB = $loTmp & self::$ms_bit15;

		// Now we do C-like, bit safe multiplication of 60 bit values: a x r
		//
		$loR = $loloA * $loloB;
		$tmp = $loloB * $lohiA;
		$hiTmp = $tmp >> self::$ms_n15;
		$loTmp = $tmp & self::$ms_bit15;
		//
		$hiR = $hiTmp;
		$loR += $loTmp << self::$ms_n15;
		$hiR += $loR >> self::$ms_n30;
		$loR &= self::$ms_bit30;
		//
		$tmp = $lohiB * $loloA;
		$hiTmp = $tmp >> self::$ms_n15;
		$loTmp = $tmp & self::$ms_bit15;
		//
		$hiR += $hiTmp;
		$loR += $loTmp << self::$ms_n15;
		$hiR += $loR >> self::$ms_n30;
		$loR &= self::$ms_bit30;
		//
		$hiR += $loloB * $hiloA;
		$hiR &= self::$ms_bit30;
		//
		$hiR += $lohiB * $lohiA;
		$hiR &= self::$ms_bit30;
		//
		$hiR += $hiloB * $loloA;
		$hiR &= self::$ms_bit30;
		//
		$hiR += ( ( $loloB * $hihiA ) & self::$ms_bit15 ) << self::$ms_n15;
		$hiR &= self::$ms_bit30;
		//
		$hiR += ( ( $lohiB * $hiloA ) & self::$ms_bit15 ) << self::$ms_n15;
		$hiR &= self::$ms_bit30;
		//
		$hiR += ( ( $hiloB * $lohiA ) & self::$ms_bit15 ) << self::$ms_n15;
		$hiR &= self::$ms_bit30;
		//
		$hiR += ( ( $hihiB * $loloA ) & self::$ms_bit15 ) << self::$ms_n15;
		$hiR &= self::$ms_bit30;
		
		// Now we do C-like, bit safe addition of 60 bit values: result + c
		//
		$loR += $this ->cL;
		$hiR += $loR >> self::$ms_n30;
		$loR &= self::$ms_bit30;
		$hiR += $this ->cH;	
		// can skip this:
		// $hiR &= self::$ms_bit30;
		
		// Now we count bitwise modulo 
		//
		$hiR &= self::$ms_bit30 >> 1;
		
		// Set new randomizer value
		$this ->rH = $hiR;
		$this ->rL = $loR;
		
		// Prepare result value
		$hiR &= self::$ms_bit30 >> 4;
		
		// Return random bits
		if ( ( 27 > $a_nBits ) && ( 0 < $a_nBits ) )
		{
			return $hiR >> 26 - $a_nBits;
		}
		else if ( 32 > $a_nBits )
		{
			$a_nBits -= 26;
			
			return ( $hiR << $a_nBits ) + ( $loR >> self::$ms_n30 - $a_nBits );
		}
		
		// Error random value is 1 to 31 bits long
		return 0;
	}
	
	// -----------------------------------------------------
	
	public function hide ( $a_sString )
	{	
		// Store prev rand value
		$hiPrev = $this ->rH;
		$loPrev = $this ->rL;
		
		$aChars = $this ->supportedChars( $a_sString, $nChars );	
		$sResult = '';
		
		if ( $this ->bR )
		{
			$this ->randomize( $aChars, $nChars );
		}
		$this ->srand( $this ->pH, $this ->pL );
		
		for ( $i = 0; $nChars > $i; $i ++ )
		{
			$iChr = $aChars[ $i ];
			
			// i % nPin convrets into an index
			// starting from zero when nPin is exceeded!
			$iPin = $this ->P[ $i % $this ->m_nPin ];
			
			$iChr =
				( $this ->rand() + $iChr ^ $iPin )
				%
				self::$ms_bitBound15
			;
			
			$iChr = $iChr + self::$ms_bitBound15;
			
			$sResult .= \mb_strcut( \base_convert( $iChr, 10, 32 ), 1 );
		}
		// Restore prev rand value
		$this ->rH = $hiPrev;
		$this ->rL = $loPrev;
		
		return $sResult;
	}
	
	// -----------------------------------------------------
	
	public function show ( $a_sHidden )
	{
		// sHidden has to be ascii string
		$nStr = \strlen( $a_sHidden );
		
		// Store prev rand value
		$hiPrev = $this ->rH;
		$loPrev = $this ->rL;
		
		$aChars = array();
		
		// Ensure that the length of string is divisible by 3
		$nStr -= $nStr % 3;
		
		$this ->srand( $this ->pH, $this ->pL );
		
		for ( $i = 0; $nStr > $i; $i += 3 )
		{
			$sNum = \substr( $a_sHidden, $i, 3 );
			
			if ( ( false !== $sNum ) && ( '' !== $sNum ) )
			{
				$iChr = \intval( $sNum, 32 );
				
				// i % nPin convrets into an index
				// starting from zero when nPin is exceeded!
				$iPin = $this ->P[ ( $i / 3 ) % $this ->m_nPin ];
				
				$iChr ^= $iPin;
				$iChr -= $this ->rand();
				
				if ( 0 > $iChr )
				{
					$iChr += self::$ms_bitBound15;
				}
				$aChars[ $i / 3 ] = $iChr;
			}
			else
			{
				// Unsupported character
				$aChars[ $i / 3 ] = 63;
			}
		}
		if ( $this ->bR )
		{
			$this ->unRandomize( $aChars, $i / 3 );
		}
		// Restore prev rand value
		$this ->rH = $hiPrev;
		$this ->rL = $loPrev;
		
		return $this ->restoreString( $aChars, $i / 3 );
	}
	
	// -----------------------------------------------------

}

// -------------------------------------------------------------------------- //

?>